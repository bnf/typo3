import { LRParser } from '@lezer/lr';
import { LRLanguage, indentNodeProp, delimitedIndent, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';
import { styleTags, tags } from '@lezer/highlight';

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_AtKeyword = {__proto__:null,"@import":22};
const parser = LRParser.deserialize({
  version: 14,
  states: "#xQYQPOOOkQQO'#C_OsQQO'#CeOOQO'#Ci'#CiOxQPO'#ClOOQO'#Cr'#CrOOQO'#Cm'#CmQYQPOOO!PQPO'#C`OOQO'#Cn'#CnO!UQQO,58yOOQO,58y,58yOOQO,59P,59POOQO,59W,59WO!^QPO,59WOOQO-E6k-E6kO!eQQO,58zOOQO-E6l-E6lOOQO1G.e1G.eOOQO1G.r1G.rOOQO'#Cc'#CcOOQO1G.f1G.f",
  stateData: "!j~OeOSPOS~OZQO[TO_SOhPOiRO~OTWOgZO~OW[O~O^]O~PYOU`O~OTWOgbO~O^cO~PYOWdO~O",
  goto: "!]gPPPhnPPrPhPPPhPPhu!PPPP!VXTOSV^TXPYRe`QVOQ^ST_V^QYPRaYXUOSV^",
  nodeNames: "âš  Comment Program IncludeStatement Attribute AttributeName Is AttributeValue StringLiteral ImportStatement AtKeyword import Identifier String ) ( Application",
  maxTerm: 25,
  nodeProps: [
    ["openedBy", 14,"("],
    ["closedBy", 15,")"]
  ],
  skippedNodes: [0,1,10],
  repeatNodeCount: 2,
  tokenData: "/{~RiX^!ppq!prs#est)hwx)sxy*`yz*e}!O*j!Q![*j![!]+O!^!_+s!_!`.`!`!a.e!b!c.j!c!}/U#R#S/U#T#o/U#y#z!p$f$g!p#BY#BZ!p$IS$I_!p$I|$JO!p$JT$JU!p$KV$KW!p&FU&FV!p~!uYe~X^!ppq!p#y#z!p$f$g!p#BY#BZ!p$IS$I_!p$I|$JO!p$JT$JU!p$KV$KW!p&FU&FV!pR#hWOY$QZp$Qpq#eqr#ers$rs#O#e#O#P$y#P~#eQ$TUOY$QZr$Qrs$gs#O$Q#O#P$l#P~$QQ$lOWQQ$oPO~$QR$yOWQiPR$|bOr$Qrs#es!P$Q!P!Q#e!Q#O$Q#O#P#e#P#U$Q#U#V#e#V#Y$Q#Y#Z#e#Z#b$Q#b#c#e#c#f$Q#f#g#e#g#h$Q#h#i#e#i#j&U#j~$QR&X[OY$QZr$Qrs$gs!Q$Q!Q![&}![!c$Q!c!i&}!i#O$Q#O#P$l#P#T$Q#T#Z&}#Z~$QR'Q[OY$QZr$Qrs$gs!Q$Q!Q!['v![!c$Q!c!i'v!i#O$Q#O#P$l#P#T$Q#T#Z'v#Z~$QR'y[OY$QZr$Qrs$gs!Q$Q!Q![(o![!c$Q!c!i(o!i#O$Q#O#P$l#P#T$Q#T#Z(o#Z~$QR(r[OY$QZr$Qrs$gs!Q$Q!Q![#e![!c$Q!c!i#e!i#O$Q#O#P$l#P#T$Q#T#Z#e#Z~$Q~)mQP~OY)hZ~)hQ)vUOY)sZw)swx$gx#O)s#O#P*Y#P~)sQ*]PO~)s~*eO_~~*jO^~P*oT[P}!O*j!Q![*j!c!}*j#R#S*j#T#o*jQ+TYTQ}!O+O!O!P+O!Q![+O![!]+O!c!}+O#R#S+O#T#o+O$}%O+O1p4U+O$Je$Jg+O~+vP!k!l+y~+|P!p!q,P~,SP!e!f,V~,YP!n!o,]~,`P!w!x,c~,fP!f!g,i~,lP!g!h,o~,rP#R#S,u~,xP!v!w,{~-OP!{!|-R~-UP!r!s-X~-[P!q!r-_~-bP!u!v-e~-hP!e!f-k~-nP!t!u-q~-tP!k!l-w~-zP!r!s-}~.QP!v!w.T~.WP![!].Z~.`Oh~~.eOU~~.jOg~~.mQ!c!}.s#T#o.s~.xSY~}!O.s!Q![.s!c!}.s#T#o.sR/]YTQ[P}!O/U!O!P+O!Q![/U![!]+O!c!}/U#R#S/U#T#o/U$}%O+O1p4U+O$Je$Jg+O",
  tokenizers: [0, 1],
  topRules: {"Program":[0,2]},
  specialized: [{term: 10, get: value => spec_AtKeyword[value] || -1}],
  tokenPrec: 0
});

const TypoScriptLanguage = LRLanguage.define({
    parser: parser.configure({
        props: [
            indentNodeProp.add({
                Application: delimitedIndent({ closing: ")", align: false })
            }),
            foldNodeProp.add({
                Application: foldInside
            }),
            styleTags({
                Identifier: tags.variableName,
                Boolean: tags.bool,
                String: tags.string,
                LineComment: tags.lineComment,
                "( )": tags.paren
            })
        ]
    }),
    languageData: {
        commentTokens: { line: ";" }
    }
});
function TypoScript() {
    return new LanguageSupport(TypoScriptLanguage);
}

export { TypoScript, TypoScriptLanguage };
