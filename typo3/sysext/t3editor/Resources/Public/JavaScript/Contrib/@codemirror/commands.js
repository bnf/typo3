import{EditorSelection,CharCategory}from"@codemirror/state";import{Text,findClusterBreak,countColumn}from"@codemirror/text";import{Direction,EditorView,PluginField}from"@codemirror/view";import{matchBrackets}from"@codemirror/matchbrackets";import{IndentContext,getIndentation,indentString,indentUnit,getIndentUnit,syntaxTree}from"@codemirror/language";import{NodeProp}from"@lezer/common";function updateSel(e,t){return EditorSelection.create(e.ranges.map(t),e.mainIndex)}function setSel(e,t){return e.update({selection:t,scrollIntoView:!0,userEvent:"select"})}function moveSel({state:e,dispatch:t},r){let n=updateSel(e.selection,r);return!n.eq(e.selection)&&(t(setSel(e,n)),!0)}function rangeEnd(e,t){return EditorSelection.cursor(t?e.to:e.from)}function cursorByChar(e,t){return moveSel(e,r=>r.empty?e.moveByChar(r,t):rangeEnd(r,t))}const cursorCharLeft=e=>cursorByChar(e,e.textDirection!=Direction.LTR),cursorCharRight=e=>cursorByChar(e,e.textDirection==Direction.LTR),cursorCharForward=e=>cursorByChar(e,!0),cursorCharBackward=e=>cursorByChar(e,!1);function cursorByGroup(e,t){return moveSel(e,r=>r.empty?e.moveByGroup(r,t):rangeEnd(r,t))}const cursorGroupLeft=e=>cursorByGroup(e,e.textDirection!=Direction.LTR),cursorGroupRight=e=>cursorByGroup(e,e.textDirection==Direction.LTR),cursorGroupForward=e=>cursorByGroup(e,!0),cursorGroupBackward=e=>cursorByGroup(e,!1);function moveBySubword(e,t,r){let n=e.state.charCategorizer(t.from);return e.moveByChar(t,r,o=>{let c=CharCategory.Space,a=t.from,i=!1,l=!1,s=!1,d=t=>{if(i)return!1;a+=r?t.length:-t.length;let o,d=n(t);if(c==CharCategory.Space&&(c=d),c!=d)return!1;if(c==CharCategory.Word)if(t.toLowerCase()==t){if(!r&&l)return!1;s=!0}else if(s){if(r)return!1;i=!0}else{if(l&&r&&n(o=e.state.sliceDoc(a,a+1))==CharCategory.Word&&o.toLowerCase()==o)return!1;l=!0}return!0};return d(o),d})}function cursorBySubword(e,t){return moveSel(e,r=>r.empty?moveBySubword(e,r,t):rangeEnd(r,t))}const cursorSubwordForward=e=>cursorBySubword(e,!0),cursorSubwordBackward=e=>cursorBySubword(e,!1);function interestingNode(e,t,r){if(t.type.prop(r))return!0;let n=t.to-t.from;return n&&(n>2||/[^\s,.;:]/.test(e.sliceDoc(t.from,t.to)))||t.firstChild}function moveBySyntax(e,t,r){let n,o,c=syntaxTree(e).resolveInner(t.head),a=r?NodeProp.closedBy:NodeProp.openedBy;for(let n=t.head;;){let t=r?c.childAfter(n):c.childBefore(n);if(!t)break;interestingNode(e,t,a)?c=t:n=r?t.to:t.from}return o=c.type.prop(a)&&(n=r?matchBrackets(e,c.from,1):matchBrackets(e,c.to,-1))&&n.matched?r?n.end.to:n.end.from:r?c.to:c.from,EditorSelection.cursor(o,r?-1:1)}const cursorSyntaxLeft=e=>moveSel(e,t=>moveBySyntax(e.state,t,e.textDirection!=Direction.LTR)),cursorSyntaxRight=e=>moveSel(e,t=>moveBySyntax(e.state,t,e.textDirection==Direction.LTR));function cursorByLine(e,t){return moveSel(e,r=>{if(!r.empty)return rangeEnd(r,t);let n=e.moveVertically(r,t);return n.head!=r.head?n:e.moveToLineBoundary(r,t)})}const cursorLineUp=e=>cursorByLine(e,!1),cursorLineDown=e=>cursorByLine(e,!0);function cursorByPage(e,t){let{state:r}=e,n=updateSel(r.selection,r=>r.empty?e.moveVertically(r,t,e.dom.clientHeight):rangeEnd(r,t));if(n.eq(r.selection))return!1;let o=e.coordsAtPos(r.selection.main.head),c=e.scrollDOM.getBoundingClientRect();return e.dispatch(setSel(r,n),{effects:o&&o.top>c.top&&o.bottom<c.bottom?EditorView.scrollIntoView(n.main.head,{y:"start",yMargin:o.top-c.top}):void 0}),!0}const cursorPageUp=e=>cursorByPage(e,!1),cursorPageDown=e=>cursorByPage(e,!0);function moveByLineBoundary(e,t,r){let n=e.lineBlockAt(t.head),o=e.moveToLineBoundary(t,r);if(o.head==t.head&&o.head!=(r?n.to:n.from)&&(o=e.moveToLineBoundary(t,r,!1)),!r&&o.head==n.from&&n.length){let r=/^\s*/.exec(e.state.sliceDoc(n.from,Math.min(n.from+100,n.to)))[0].length;r&&t.head!=n.from+r&&(o=EditorSelection.cursor(n.from+r))}return o}const cursorLineBoundaryForward=e=>moveSel(e,t=>moveByLineBoundary(e,t,!0)),cursorLineBoundaryBackward=e=>moveSel(e,t=>moveByLineBoundary(e,t,!1)),cursorLineStart=e=>moveSel(e,t=>EditorSelection.cursor(e.lineBlockAt(t.head).from,1)),cursorLineEnd=e=>moveSel(e,t=>EditorSelection.cursor(e.lineBlockAt(t.head).to,-1));function toMatchingBracket(e,t,r){let n=!1,o=updateSel(e.selection,t=>{let o=matchBrackets(e,t.head,-1)||matchBrackets(e,t.head,1)||t.head>0&&matchBrackets(e,t.head-1,1)||t.head<e.doc.length&&matchBrackets(e,t.head+1,-1);if(!o||!o.end)return t;n=!0;let c=o.start.from==t.head?o.end.to:o.end.from;return r?EditorSelection.range(t.anchor,c):EditorSelection.cursor(c)});return!!n&&(t(setSel(e,o)),!0)}const cursorMatchingBracket=({state:e,dispatch:t})=>toMatchingBracket(e,t,!1),selectMatchingBracket=({state:e,dispatch:t})=>toMatchingBracket(e,t,!0);function extendSel(e,t){let r=updateSel(e.state.selection,e=>{let r=t(e);return EditorSelection.range(e.anchor,r.head,r.goalColumn)});return!r.eq(e.state.selection)&&(e.dispatch(setSel(e.state,r)),!0)}function selectByChar(e,t){return extendSel(e,r=>e.moveByChar(r,t))}const selectCharLeft=e=>selectByChar(e,e.textDirection!=Direction.LTR),selectCharRight=e=>selectByChar(e,e.textDirection==Direction.LTR),selectCharForward=e=>selectByChar(e,!0),selectCharBackward=e=>selectByChar(e,!1);function selectByGroup(e,t){return extendSel(e,r=>e.moveByGroup(r,t))}const selectGroupLeft=e=>selectByGroup(e,e.textDirection!=Direction.LTR),selectGroupRight=e=>selectByGroup(e,e.textDirection==Direction.LTR),selectGroupForward=e=>selectByGroup(e,!0),selectGroupBackward=e=>selectByGroup(e,!1);function selectBySubword(e,t){return extendSel(e,r=>moveBySubword(e,r,t))}const selectSubwordForward=e=>selectBySubword(e,!0),selectSubwordBackward=e=>selectBySubword(e,!1),selectSyntaxLeft=e=>extendSel(e,t=>moveBySyntax(e.state,t,e.textDirection!=Direction.LTR)),selectSyntaxRight=e=>extendSel(e,t=>moveBySyntax(e.state,t,e.textDirection==Direction.LTR));function selectByLine(e,t){return extendSel(e,r=>e.moveVertically(r,t))}const selectLineUp=e=>selectByLine(e,!1),selectLineDown=e=>selectByLine(e,!0);function selectByPage(e,t){return extendSel(e,r=>e.moveVertically(r,t,e.dom.clientHeight))}const selectPageUp=e=>selectByPage(e,!1),selectPageDown=e=>selectByPage(e,!0),selectLineBoundaryForward=e=>extendSel(e,t=>moveByLineBoundary(e,t,!0)),selectLineBoundaryBackward=e=>extendSel(e,t=>moveByLineBoundary(e,t,!1)),selectLineStart=e=>extendSel(e,t=>EditorSelection.cursor(e.lineBlockAt(t.head).from)),selectLineEnd=e=>extendSel(e,t=>EditorSelection.cursor(e.lineBlockAt(t.head).to)),cursorDocStart=({state:e,dispatch:t})=>(t(setSel(e,{anchor:0})),!0),cursorDocEnd=({state:e,dispatch:t})=>(t(setSel(e,{anchor:e.doc.length})),!0),selectDocStart=({state:e,dispatch:t})=>(t(setSel(e,{anchor:e.selection.main.anchor,head:0})),!0),selectDocEnd=({state:e,dispatch:t})=>(t(setSel(e,{anchor:e.selection.main.anchor,head:e.doc.length})),!0),selectAll=({state:e,dispatch:t})=>(t(e.update({selection:{anchor:0,head:e.doc.length},userEvent:"select"})),!0),selectLine=({state:e,dispatch:t})=>{let r=selectedLineBlocks(e).map(({from:t,to:r})=>EditorSelection.range(t,Math.min(r+1,e.doc.length)));return t(e.update({selection:EditorSelection.create(r),userEvent:"select"})),!0},selectParentSyntax=({state:e,dispatch:t})=>{let r=updateSel(e.selection,t=>{var r;let n=syntaxTree(e).resolveInner(t.head,1);for(;!(n.from<t.from&&n.to>=t.to||n.to>t.to&&n.from<=t.from)&&(null===(r=n.parent)||void 0===r?void 0:r.parent);)n=n.parent;return EditorSelection.range(n.to,n.from)});return t(setSel(e,r)),!0},simplifySelection=({state:e,dispatch:t})=>{let r=e.selection,n=null;return r.ranges.length>1?n=EditorSelection.create([r.main]):r.main.empty||(n=EditorSelection.create([EditorSelection.cursor(r.main.head)])),!!n&&(t(setSel(e,n)),!0)};function deleteBy({state:e,dispatch:t},r){if(e.readOnly)return!1;let n="delete.selection",o=e.changeByRange(e=>{let{from:t,to:o}=e;if(t==o){let e=r(t);e<t?n="delete.backward":e>t&&(n="delete.forward"),t=Math.min(t,e),o=Math.max(o,e)}return t==o?{range:e}:{changes:{from:t,to:o},range:EditorSelection.cursor(t)}});return!o.changes.empty&&(t(e.update(o,{scrollIntoView:!0,userEvent:n})),!0)}function skipAtomic(e,t,r){if(e instanceof EditorView)for(let n of e.pluginField(PluginField.atomicRanges))n.between(t,t,(e,n)=>{e<t&&n>t&&(t=r?n:e)});return t}const deleteByChar=(e,t)=>deleteBy(e,r=>{let n,o,{state:c}=e,a=c.doc.lineAt(r);if(!t&&r>a.from&&r<a.from+200&&!/[^ \t]/.test(n=a.text.slice(0,r-a.from))){if("\t"==n[n.length-1])return r-1;let e=countColumn(n,c.tabSize)%getIndentUnit(c)||getIndentUnit(c);for(let t=0;t<e&&" "==n[n.length-1-t];t++)r--;o=r}else o=findClusterBreak(a.text,r-a.from,t)+a.from,o==r&&a.number!=(t?c.doc.lines:1)&&(o+=t?1:-1);return skipAtomic(e,o,t)}),deleteCharBackward=e=>deleteByChar(e,!1),deleteCharForward=e=>deleteByChar(e,!0),deleteByGroup=(e,t)=>deleteBy(e,r=>{let n=r,{state:o}=e,c=o.doc.lineAt(n),a=o.charCategorizer(n);for(let e=null;;){if(n==(t?c.to:c.from)){n==r&&c.number!=(t?o.doc.lines:1)&&(n+=t?1:-1);break}let i=findClusterBreak(c.text,n-c.from,t)+c.from,l=c.text.slice(Math.min(n,i)-c.from,Math.max(n,i)-c.from),s=a(l);if(null!=e&&s!=e)break;" "==l&&n==r||(e=s),n=i}return skipAtomic(e,n,t)}),deleteGroupBackward=e=>deleteByGroup(e,!1),deleteGroupForward=e=>deleteByGroup(e,!0),deleteToLineEnd=e=>deleteBy(e,t=>{let r=e.lineBlockAt(t).to;return skipAtomic(e,t<r?r:Math.min(e.state.doc.length,t+1),!0)}),deleteToLineStart=e=>deleteBy(e,t=>{let r=e.lineBlockAt(t).from;return skipAtomic(e,t>r?r:Math.max(0,t-1),!1)}),deleteTrailingWhitespace=({state:e,dispatch:t})=>{if(e.readOnly)return!1;let r=[];for(let t=0,n="",o=e.doc.iter();;){if(o.next(),o.lineBreak||o.done){let e=n.search(/\s+$/);if(e>-1&&r.push({from:t-(n.length-e),to:t}),o.done)break;n=""}else n=o.value;t+=o.value.length}return!!r.length&&(t(e.update({changes:r,userEvent:"delete"})),!0)},splitLine=({state:e,dispatch:t})=>{if(e.readOnly)return!1;let r=e.changeByRange(e=>({changes:{from:e.from,to:e.to,insert:Text.of(["",""])},range:EditorSelection.cursor(e.from)}));return t(e.update(r,{scrollIntoView:!0,userEvent:"input"})),!0},transposeChars=({state:e,dispatch:t})=>{if(e.readOnly)return!1;let r=e.changeByRange(t=>{if(!t.empty||0==t.from||t.from==e.doc.length)return{range:t};let r=t.from,n=e.doc.lineAt(r),o=r==n.from?r-1:findClusterBreak(n.text,r-n.from,!1)+n.from,c=r==n.to?r+1:findClusterBreak(n.text,r-n.from,!0)+n.from;return{changes:{from:o,to:c,insert:e.doc.slice(r,c).append(e.doc.slice(o,r))},range:EditorSelection.cursor(c)}});return!r.changes.empty&&(t(e.update(r,{scrollIntoView:!0,userEvent:"move.character"})),!0)};function selectedLineBlocks(e){let t=[],r=-1;for(let n of e.selection.ranges){let o=e.doc.lineAt(n.from),c=e.doc.lineAt(n.to);if(n.empty||n.to!=c.from||(c=e.doc.lineAt(n.to-1)),r>=o.number){let e=t[t.length-1];e.to=c.to,e.ranges.push(n)}else t.push({from:o.from,to:c.to,ranges:[n]});r=c.number+1}return t}function moveLine(e,t,r){if(e.readOnly)return!1;let n=[],o=[];for(let t of selectedLineBlocks(e)){if(r?t.to==e.doc.length:0==t.from)continue;let c=e.doc.lineAt(r?t.to+1:t.from-1),a=c.length+1;if(r){n.push({from:t.to,to:c.to},{from:t.from,insert:c.text+e.lineBreak});for(let r of t.ranges)o.push(EditorSelection.range(Math.min(e.doc.length,r.anchor+a),Math.min(e.doc.length,r.head+a)))}else{n.push({from:c.from,to:t.from},{from:t.to,insert:e.lineBreak+c.text});for(let e of t.ranges)o.push(EditorSelection.range(e.anchor-a,e.head-a))}}return!!n.length&&(t(e.update({changes:n,scrollIntoView:!0,selection:EditorSelection.create(o,e.selection.mainIndex),userEvent:"move.line"})),!0)}const moveLineUp=({state:e,dispatch:t})=>moveLine(e,t,!1),moveLineDown=({state:e,dispatch:t})=>moveLine(e,t,!0);function copyLine(e,t,r){if(e.readOnly)return!1;let n=[];for(let t of selectedLineBlocks(e))r?n.push({from:t.from,insert:e.doc.slice(t.from,t.to)+e.lineBreak}):n.push({from:t.to,insert:e.lineBreak+e.doc.slice(t.from,t.to)});return t(e.update({changes:n,scrollIntoView:!0,userEvent:"input.copyline"})),!0}const copyLineUp=({state:e,dispatch:t})=>copyLine(e,t,!1),copyLineDown=({state:e,dispatch:t})=>copyLine(e,t,!0),deleteLine=e=>{if(e.state.readOnly)return!1;let{state:t}=e,r=t.changes(selectedLineBlocks(t).map(({from:e,to:r})=>(e>0?e--:r<t.doc.length&&r++,{from:e,to:r}))),n=updateSel(t.selection,t=>e.moveVertically(t,!0)).map(r);return e.dispatch({changes:r,selection:n,scrollIntoView:!0,userEvent:"delete.line"}),!0},insertNewline=({state:e,dispatch:t})=>(t(e.update(e.replaceSelection(e.lineBreak),{scrollIntoView:!0,userEvent:"input"})),!0);function isBetweenBrackets(e,t){if(/\(\)|\[\]|\{\}/.test(e.sliceDoc(t-1,t+1)))return{from:t,to:t};let r,n=syntaxTree(e).resolveInner(t),o=n.childBefore(t),c=n.childAfter(t);return o&&c&&o.to<=t&&c.from>=t&&(r=o.type.prop(NodeProp.closedBy))&&r.indexOf(c.name)>-1&&e.doc.lineAt(o.to).from==e.doc.lineAt(c.from).from?{from:o.to,to:c.from}:null}const insertNewlineAndIndent=newlineAndIndent(!1),insertBlankLine=newlineAndIndent(!0);function newlineAndIndent(e){return({state:t,dispatch:r})=>{if(t.readOnly)return!1;let n=t.changeByRange(r=>{let{from:n,to:o}=r,c=t.doc.lineAt(n),a=!e&&n==o&&isBetweenBrackets(t,n);e&&(n=o=(o<=c.to?c:t.doc.lineAt(o)).to);let i=new IndentContext(t,{simulateBreak:n,simulateDoubleBreak:!!a}),l=getIndentation(i,n);for(null==l&&(l=/^\s*/.exec(t.doc.lineAt(n).text)[0].length);o<c.to&&/\s/.test(c.text[o-c.from]);)o++;a?({from:n,to:o}=a):n>c.from&&n<c.from+100&&!/\S/.test(c.text.slice(0,n))&&(n=c.from);let s=["",indentString(t,l)];return a&&s.push(indentString(t,i.lineIndent(c.from,-1))),{changes:{from:n,to:o,insert:Text.of(s)},range:EditorSelection.cursor(n+1+s[1].length)}});return r(t.update(n,{scrollIntoView:!0,userEvent:"input"})),!0}}function changeBySelectedLine(e,t){let r=-1;return e.changeByRange(n=>{let o=[];for(let c=n.from;c<=n.to;){let a=e.doc.lineAt(c);a.number>r&&(n.empty||n.to>a.from)&&(t(a,o,n),r=a.number),c=a.to+1}let c=e.changes(o);return{changes:o,range:EditorSelection.range(c.mapPos(n.anchor,1),c.mapPos(n.head,1))}})}const indentSelection=({state:e,dispatch:t})=>{if(e.readOnly)return!1;let r=Object.create(null),n=new IndentContext(e,{overrideIndentation:e=>{let t=r[e];return null==t?-1:t}}),o=changeBySelectedLine(e,(t,o,c)=>{let a=getIndentation(n,t.from);if(null==a)return;/\S/.test(t.text)||(a=0);let i=/^\s*/.exec(t.text)[0],l=indentString(e,a);(i!=l||c.from<t.from+i.length)&&(r[t.from]=a,o.push({from:t.from,to:t.from+i.length,insert:l}))});return o.changes.empty||t(e.update(o,{userEvent:"indent"})),!0},indentMore=({state:e,dispatch:t})=>!e.readOnly&&(t(e.update(changeBySelectedLine(e,(t,r)=>{r.push({from:t.from,insert:e.facet(indentUnit)})}),{userEvent:"input.indent"})),!0),indentLess=({state:e,dispatch:t})=>!e.readOnly&&(t(e.update(changeBySelectedLine(e,(t,r)=>{let n=/^\s*/.exec(t.text)[0];if(!n)return;let o=countColumn(n,e.tabSize),c=0,a=indentString(e,Math.max(0,o-getIndentUnit(e)));for(;c<n.length&&c<a.length&&n.charCodeAt(c)==a.charCodeAt(c);)c++;r.push({from:t.from+c,to:t.from+n.length,insert:a.slice(c)})}),{userEvent:"delete.dedent"})),!0),insertTab=({state:e,dispatch:t})=>e.selection.ranges.some(e=>!e.empty)?indentMore({state:e,dispatch:t}):(t(e.update(e.replaceSelection("\t"),{scrollIntoView:!0,userEvent:"input"})),!0),emacsStyleKeymap=[{key:"Ctrl-b",run:cursorCharLeft,shift:selectCharLeft,preventDefault:!0},{key:"Ctrl-f",run:cursorCharRight,shift:selectCharRight},{key:"Ctrl-p",run:cursorLineUp,shift:selectLineUp},{key:"Ctrl-n",run:cursorLineDown,shift:selectLineDown},{key:"Ctrl-a",run:cursorLineStart,shift:selectLineStart},{key:"Ctrl-e",run:cursorLineEnd,shift:selectLineEnd},{key:"Ctrl-d",run:deleteCharForward},{key:"Ctrl-h",run:deleteCharBackward},{key:"Ctrl-k",run:deleteToLineEnd},{key:"Ctrl-Alt-h",run:deleteGroupBackward},{key:"Ctrl-o",run:splitLine},{key:"Ctrl-t",run:transposeChars},{key:"Ctrl-v",run:cursorPageDown},{key:"Alt-v",run:cursorPageUp}],standardKeymap=[{key:"ArrowLeft",run:cursorCharLeft,shift:selectCharLeft,preventDefault:!0},{key:"Mod-ArrowLeft",mac:"Alt-ArrowLeft",run:cursorGroupLeft,shift:selectGroupLeft},{mac:"Cmd-ArrowLeft",run:cursorLineBoundaryBackward,shift:selectLineBoundaryBackward},{key:"ArrowRight",run:cursorCharRight,shift:selectCharRight,preventDefault:!0},{key:"Mod-ArrowRight",mac:"Alt-ArrowRight",run:cursorGroupRight,shift:selectGroupRight},{mac:"Cmd-ArrowRight",run:cursorLineBoundaryForward,shift:selectLineBoundaryForward},{key:"ArrowUp",run:cursorLineUp,shift:selectLineUp,preventDefault:!0},{mac:"Cmd-ArrowUp",run:cursorDocStart,shift:selectDocStart},{mac:"Ctrl-ArrowUp",run:cursorPageUp,shift:selectPageUp},{key:"ArrowDown",run:cursorLineDown,shift:selectLineDown,preventDefault:!0},{mac:"Cmd-ArrowDown",run:cursorDocEnd,shift:selectDocEnd},{mac:"Ctrl-ArrowDown",run:cursorPageDown,shift:selectPageDown},{key:"PageUp",run:cursorPageUp,shift:selectPageUp},{key:"PageDown",run:cursorPageDown,shift:selectPageDown},{key:"Home",run:cursorLineBoundaryBackward,shift:selectLineBoundaryBackward},{key:"Mod-Home",run:cursorDocStart,shift:selectDocStart},{key:"End",run:cursorLineBoundaryForward,shift:selectLineBoundaryForward},{key:"Mod-End",run:cursorDocEnd,shift:selectDocEnd},{key:"Enter",run:insertNewlineAndIndent},{key:"Mod-a",run:selectAll},{key:"Backspace",run:deleteCharBackward,shift:deleteCharBackward},{key:"Delete",run:deleteCharForward},{key:"Mod-Backspace",mac:"Alt-Backspace",run:deleteGroupBackward},{key:"Mod-Delete",mac:"Alt-Delete",run:deleteGroupForward},{mac:"Mod-Backspace",run:deleteToLineStart},{mac:"Mod-Delete",run:deleteToLineEnd}].concat(emacsStyleKeymap.map(e=>({mac:e.key,run:e.run,shift:e.shift}))),defaultKeymap=[{key:"Alt-ArrowLeft",mac:"Ctrl-ArrowLeft",run:cursorSyntaxLeft,shift:selectSyntaxLeft},{key:"Alt-ArrowRight",mac:"Ctrl-ArrowRight",run:cursorSyntaxRight,shift:selectSyntaxRight},{key:"Alt-ArrowUp",run:moveLineUp},{key:"Shift-Alt-ArrowUp",run:copyLineUp},{key:"Alt-ArrowDown",run:moveLineDown},{key:"Shift-Alt-ArrowDown",run:copyLineDown},{key:"Escape",run:simplifySelection},{key:"Mod-Enter",run:insertBlankLine},{key:"Alt-l",mac:"Ctrl-l",run:selectLine},{key:"Mod-i",run:selectParentSyntax,preventDefault:!0},{key:"Mod-[",run:indentLess},{key:"Mod-]",run:indentMore},{key:"Mod-Alt-\\",run:indentSelection},{key:"Shift-Mod-k",run:deleteLine},{key:"Shift-Mod-\\",run:cursorMatchingBracket}].concat(standardKeymap),indentWithTab={key:"Tab",run:indentMore,shift:indentLess};export{copyLineDown,copyLineUp,cursorCharBackward,cursorCharForward,cursorCharLeft,cursorCharRight,cursorDocEnd,cursorDocStart,cursorGroupBackward,cursorGroupForward,cursorGroupLeft,cursorGroupRight,cursorLineBoundaryBackward,cursorLineBoundaryForward,cursorLineDown,cursorLineEnd,cursorLineStart,cursorLineUp,cursorMatchingBracket,cursorPageDown,cursorPageUp,cursorSubwordBackward,cursorSubwordForward,cursorSyntaxLeft,cursorSyntaxRight,defaultKeymap,deleteCharBackward,deleteCharForward,deleteGroupBackward,deleteGroupForward,deleteLine,deleteToLineEnd,deleteToLineStart,deleteTrailingWhitespace,emacsStyleKeymap,indentLess,indentMore,indentSelection,indentWithTab,insertBlankLine,insertNewline,insertNewlineAndIndent,insertTab,moveLineDown,moveLineUp,selectAll,selectCharBackward,selectCharForward,selectCharLeft,selectCharRight,selectDocEnd,selectDocStart,selectGroupBackward,selectGroupForward,selectGroupLeft,selectGroupRight,selectLine,selectLineBoundaryBackward,selectLineBoundaryForward,selectLineDown,selectLineEnd,selectLineStart,selectLineUp,selectMatchingBracket,selectPageDown,selectPageUp,selectParentSyntax,selectSubwordBackward,selectSubwordForward,selectSyntaxLeft,selectSyntaxRight,simplifySelection,splitLine,standardKeymap,transposeChars};