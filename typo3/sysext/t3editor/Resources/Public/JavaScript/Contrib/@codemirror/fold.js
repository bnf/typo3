import{StateEffect,StateField,Facet,combineConfig}from"@codemirror/state";import{Decoration,EditorView,WidgetType,ViewPlugin}from"@codemirror/view";import{foldable,language}from"@codemirror/language";import{gutter,GutterMarker}from"@codemirror/gutter";import{RangeSet,RangeSetBuilder}from"@codemirror/rangeset";function mapRange(e,t){let o=t.mapPos(e.from,1),l=t.mapPos(e.to,-1);return o>=l?void 0:{from:o,to:l}}const foldEffect=StateEffect.define({map:mapRange}),unfoldEffect=StateEffect.define({map:mapRange});function selectedLines(e){let t=[];for(let{head:o}of e.state.selection.ranges)t.some(e=>e.from<=o&&e.to>=o)||t.push(e.lineBlockAt(o));return t}const foldState=StateField.define({create:()=>Decoration.none,update(e,t){e=e.map(t.changes);for(let o of t.effects)o.is(foldEffect)&&!foldExists(e,o.value.from,o.value.to)?e=e.update({add:[foldWidget.range(o.value.from,o.value.to)]}):o.is(unfoldEffect)&&(e=e.update({filter:(e,t)=>o.value.from!=e||o.value.to!=t,filterFrom:o.value.from,filterTo:o.value.to}));if(t.selection){let o=!1,{head:l}=t.selection.main;e.between(l,l,(e,t)=>{e<l&&t>l&&(o=!0)}),o&&(e=e.update({filterFrom:l,filterTo:l,filter:(e,t)=>t<=l||e>=l}))}return e},provide:e=>EditorView.decorations.from(e)});function foldedRanges(e){return e.field(foldState,!1)||RangeSet.empty}function foldInside(e,t,o){var l;let r=null;return null===(l=e.field(foldState,!1))||void 0===l||l.between(t,o,(e,t)=>{(!r||r.from>e)&&(r={from:e,to:t})}),r}function foldExists(e,t,o){let l=!1;return e.between(t,t,(e,r)=>{e==t&&r==o&&(l=!0)}),l}function maybeEnable(e,t){return e.field(foldState,!1)?t:t.concat(StateEffect.appendConfig.of(codeFolding()))}const foldCode=e=>{for(let t of selectedLines(e)){let o=foldable(e.state,t.from,t.to);if(o)return e.dispatch({effects:maybeEnable(e.state,[foldEffect.of(o),announceFold(e,o)])}),!0}return!1},unfoldCode=e=>{if(!e.state.field(foldState,!1))return!1;let t=[];for(let o of selectedLines(e)){let l=foldInside(e.state,o.from,o.to);l&&t.push(unfoldEffect.of(l),announceFold(e,l,!1))}return t.length&&e.dispatch({effects:t}),t.length>0};function announceFold(e,t,o=!0){let l=e.state.doc.lineAt(t.from).number,r=e.state.doc.lineAt(t.to).number;return EditorView.announce.of(`${e.state.phrase(o?"Folded lines":"Unfolded lines")} ${l} ${e.state.phrase("to")} ${r}.`)}const foldAll=e=>{let{state:t}=e,o=[];for(let l=0;l<t.doc.length;){let r=e.lineBlockAt(l),n=foldable(t,r.from,r.to);n&&o.push(foldEffect.of(n)),l=(n?e.lineBlockAt(n.to):r).to+1}return o.length&&e.dispatch({effects:maybeEnable(e.state,o)}),!!o.length},unfoldAll=e=>{let t=e.state.field(foldState,!1);if(!t||!t.size)return!1;let o=[];return t.between(0,e.state.doc.length,(e,t)=>{o.push(unfoldEffect.of({from:e,to:t}))}),e.dispatch({effects:o}),!0},foldKeymap=[{key:"Ctrl-Shift-[",mac:"Cmd-Alt-[",run:foldCode},{key:"Ctrl-Shift-]",mac:"Cmd-Alt-]",run:unfoldCode},{key:"Ctrl-Alt-[",run:foldAll},{key:"Ctrl-Alt-]",run:unfoldAll}],defaultConfig={placeholderDOM:null,placeholderText:"…"},foldConfig=Facet.define({combine:e=>combineConfig(e,defaultConfig)});function codeFolding(e){let t=[foldState,baseTheme];return e&&t.push(foldConfig.of(e)),t}const foldWidget=Decoration.replace({widget:new class extends WidgetType{ignoreEvents(){return!1}toDOM(e){let{state:t}=e,o=t.facet(foldConfig),l=t=>{let o=e.lineBlockAt(e.posAtDOM(t.target)),l=foldInside(e.state,o.from,o.to);l&&e.dispatch({effects:unfoldEffect.of(l)}),t.preventDefault()};if(o.placeholderDOM)return o.placeholderDOM(e,l);let r=document.createElement("span");return r.textContent=o.placeholderText,r.setAttribute("aria-label",t.phrase("folded code")),r.title=t.phrase("unfold"),r.className="cm-foldPlaceholder",r.onclick=l,r}}}),foldGutterDefaults={openText:"⌄",closedText:"›",markerDOM:null};class FoldMarker extends GutterMarker{constructor(e,t){super(),this.config=e,this.open=t}eq(e){return this.config==e.config&&this.open==e.open}toDOM(e){if(this.config.markerDOM)return this.config.markerDOM(this.open);let t=document.createElement("span");return t.textContent=this.open?this.config.openText:this.config.closedText,t.title=e.state.phrase(this.open?"Fold line":"Unfold line"),t}}function foldGutter(e={}){let t=Object.assign(Object.assign({},foldGutterDefaults),e),o=new FoldMarker(t,!0),l=new FoldMarker(t,!1),r=ViewPlugin.fromClass(class{constructor(e){this.from=e.viewport.from,this.markers=this.buildMarkers(e)}update(e){(e.docChanged||e.viewportChanged||e.startState.facet(language)!=e.state.facet(language)||e.startState.field(foldState,!1)!=e.state.field(foldState,!1))&&(this.markers=this.buildMarkers(e.view))}buildMarkers(e){let t=new RangeSetBuilder;for(let r of e.viewportLineBlocks){let n=foldInside(e.state,r.from,r.to)?l:foldable(e.state,r.from,r.to)?o:null;n&&t.add(r.from,r.from,n)}return t.finish()}});return[r,gutter({class:"cm-foldGutter",markers(e){var t;return(null===(t=e.plugin(r))||void 0===t?void 0:t.markers)||RangeSet.empty},initialSpacer:()=>new FoldMarker(t,!1),domEventHandlers:{click:(e,t)=>{let o=foldInside(e.state,t.from,t.to);if(o)return e.dispatch({effects:unfoldEffect.of(o)}),!0;let l=foldable(e.state,t.from,t.to);return!!l&&(e.dispatch({effects:foldEffect.of(l)}),!0)}}}),codeFolding()]}const baseTheme=EditorView.baseTheme({".cm-foldPlaceholder":{backgroundColor:"#eee",border:"1px solid #ddd",color:"#888",borderRadius:".2em",margin:"0 1px",padding:"0 1px",cursor:"pointer"},".cm-foldGutter span":{padding:"0 1px",cursor:"pointer"}});export{codeFolding,foldAll,foldCode,foldEffect,foldGutter,foldKeymap,foldedRanges,unfoldAll,unfoldCode,unfoldEffect};